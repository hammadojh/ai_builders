<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Agents</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Default layout for landscape mode */
        #agentsContainer {
            flex-direction: row;
        }

        /* Portrait mode layout */
        @media (orientation: portrait) {
            #agentsContainer {
                flex-direction: column;
            }
            .agent {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        .message-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px;
            overflow-y: auto;
            height: 100%;
            justify-content: flex-end; /* Keep current message at the bottom */
        }

        .message {
            transition: all 0.5s ease;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            min-height: 50px;
            opacity: 1;
            transform: translateY(0);
        }

        .message.typing {
            opacity: 0;
            transform: translateY(20px);
        }

        .message.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .message.fading {
            opacity: 0;
            transform: translateY(-20px);
        }

        .faded {
            opacity: 0.3;
            transform: translateY(-20px);
        }

        .agent {
            height: 400px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible; /* Allow context menu to be visible outside */
        }

        .message-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center the message vertically */
            align-items: center;
            padding: 20px;
            overflow: hidden; /* Hide overflow content */
        }

        .message {
            transition: all 0.5s ease;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            min-height: 50px;
            max-width: 90%;
            width: fit-content;
            margin: 0 auto;
        }

        .context-input {
            position: absolute;
            top: 64px;  /* Increased from 12px to move it below the buttons */
            left: 2px;
            right: 2px;
            z-index: 15;
            background-color: rgba(0, 0, 0, 0.8);  /* Add semi-transparent background */
            padding: 24px;  /* Add some padding */
            border-radius: 8px;  /* Round the corners */
        }

        /* Smooth text appearance */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .character {
            display: inline-block;
            animation: fadeIn 0.2s ease-in-out;
        }

        /* Add these new styles */
        .agent .flex.gap-1 {
            z-index: 20; /* Make buttons clickable */
        }

        .context-input {
            position: absolute;
            top: 12px;
            left: 2px;
            right: 2px;
            z-index: 15; /* Lower than buttons but higher than messages */
        }

        .message-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            z-index: 10; /* Lower than both buttons and context input */
        }
        #chatInput{
            z-index: 25;
        }

        /* Replace the pulse animation with simple state styles */
        .voice-button {
            transition: background-color 0.3s ease;
        }

        .voice-button.enabled {
            background-color: rgb(185, 28, 28); /* Dark red for enabled state */
        }

        /* Remove the old pulse animation styles */
        .voice-active {
            /* Remove this class */
        }

        /* Add adaptive text color based on background */
        .agent.bg-gray-300 .message,
        .agent.bg-gray-400 .message {
            color: #1a202c; /* Dark text for light backgrounds */
        }

        /* Style for circular buttons */
        #addAgent, #removeAgent {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 30; /* Higher than chatInput's z-index of 25 */
            position: relative; /* Ensure z-index works */
        }

        #addAgent:hover, #removeAgent:hover {
            transform: scale(1.1);
        }

        /* Update the container div style */
        .agent-controls {
            bottom: 100px;
            text-align: center;
            z-index: 30; /* Match the buttons */
        }

        /* ... existing styles ... */

        .loading-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .loading-indicator.visible {
            opacity: 1;
        }

        .loading-dots {
            display: flex;
            gap: 4px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: currentColor;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes pulse {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Add to your existing styles */
        #mainContainer {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px); /* Leave space for chat input */
            padding: 1rem;
            gap: 1rem;
        }

        #canvas-container {
            height: 50vh;
            min-height: 50vh;
            max-height: 50vh;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        #agents-column {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            width: 100%;
            min-height: 200px; /* Ensure minimum height for agents area */
        }

        .agent {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            max-width: 300px;
            min-width: 200px;
            padding: 1rem;
            border: 2px solid rgb(104, 104, 104); /* Add border */
            border-radius: 1rem;
            background: rgba(0, 0, 0, 0.1); /* Slight background */
            backdrop-filter: blur(5px); /* Optional: adds a glass effect */
            margin: 0.5rem;
            transition: all 0.3s ease; /* Smooth transition for hover effects */
            padding: 1rem;
        }

        .agent:hover {
            border-color: rgba(255, 255, 255, 0.2); /* Brighter border on hover */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1); /* Subtle glow effect */
        }

        /* Update for mobile */
        @media (max-width: 768px) {
            .agent {
                min-width: 100px;
                max-width: 150px;
                padding: 0.5rem;
            }
        }

        .message-container {
            width: 100%;
            text-align: center;
            min-height: 60px; /* Ensure space for messages */
        }

        .message {
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 0.5rem;
            padding: 0.5rem;
            color: white;
            font-size: 0.875rem;
            word-wrap: break-word;
        }

        .agent-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .agent-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
        }

        .agent button {
            width: 100%;
            padding: 0.4rem;
            font-size: 0.75rem;
            border-radius: 0.25rem;
            transition: all 0.2s;
        }

        .agent button:hover {
            transform: scale(1.05);
        }

        /* Canvas styles */
        #canvas-container {
            height: 50vh;
            min-height: 50vh;
            max-height: 50vh;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        /* Editor and preview heights */
        #canvas-editor, 
        #canvas-preview {
            height: calc(50vh - 5rem) !important;
        }

        /* Message container and text styles */
        .message-container {
            position: relative; /* Changed from absolute */
            width: 200px;
            text-align: center;
            margin-bottom: 1rem; /* Add space between message and circle */
        }

        .message {
            font-size: 0.875rem;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 0.5rem;
            padding: 0.5rem;
            color: white; /* Ensure text is visible */
        }

        /* Agent layout */
        .agent {
            display: flex;
            flex-direction: column-reverse; /* Reverse order to put message above circle */
            align-items: center;
            gap: 0.5rem;
            width: auto;
            min-height: auto;
            background: none;
            padding: 0;
            margin: 2rem 1rem; /* Add margin around agents */
        }

        .agent-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        /* Update agents column layout */
        #agents-column {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            gap: 2rem;
            padding: 1rem;
            width: 100%;
            margin-top: 2rem; /* Add space after canvas */
        }

        /* Update the chat input styles */
        #mainContainer {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px); /* Leave space for chat input */
            padding: 1rem;
            gap: 1rem;
        }

        #chatInput {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            z-index: 1000; /* Ensure it's above other elements */
            background: white;
            padding: 1rem;
            border: 2px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Add/Update these styles */
        #agents-column {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 1rem;
            gap: 3rem; /* Increased gap between agents */
            margin: 1rem auto;
            max-width: 1200px; /* Increased from 800px */
        }

        .agent {
            flex: 0 1 auto;
            width: 300px; /* Increased from 250px */
            min-width: 250px; /* Increased from 200px */
            max-width: 350px; /* Increased from 300px */
            margin: 0 1.5rem; /* Increased horizontal margin */
        }

        /* Update for mobile */
        @media (max-width: 768px) {
            #agents-column {
                gap: 1rem;
                padding: 0.5rem;
            }
            
            .agent {
                width: 200px;
                min-width: 150px;
                margin: 0 0.5rem;
            }
        }

        .message-container {
            width: 120px; /* Match min-width of agent */
            min-height: 40px;
        }

        .message {
            font-size: 0.75rem;
            padding: 0.25rem;
        }

        /* Media queries for responsive design */
        @media (max-width: 768px) {
            #canvas-container {
                height: 40vh; /* Slightly smaller on mobile */
            }

            #agents-column {
                gap: 0.5rem;
                padding: 0.5rem;
            }

            .agent {
                min-width: 80px; /* Even smaller on mobile */
                max-width: 100px;
                margin: 0.25rem;
            }

            .message-container {
                width: 100px;
            }

            .agent-buttons button {
                padding: 0.2rem;
                font-size: 0.65rem;
            }

            #chatInput {
                width: 90%;
                padding: 0.5rem;
                font-size: 1rem;
                bottom: 10px;
            }

            .agent-controls {
                bottom: 60px;
            }
        }

        /* For very small screens */
        @media (max-width: 480px) {
            .agent {
                min-width: 70px;
                max-width: 90px;
            }

            .agent-circle {
                width: 35px;
                height: 35px;
                font-size: 0.75rem;
            }

            .message {
                font-size: 0.7rem;
            }

            .agent-buttons button {
                font-size: 0.6rem;
            }
        }

        .agent-circle {
            width: auto;
            min-width: 60px;
            height: 60px;
            border-radius: 30px;
            padding: 0 15px;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            margin: 0.5rem 0;
        }

        @media (max-width: 768px) {
            .agent-circle {
                min-width: 50px;
                height: 50px;
                font-size: 0.75rem;
                padding: 0 10px;
            }
        }

        .agent-circle {
            cursor: pointer;
            position: relative;
        }

        .role-input {
            outline: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .role-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .edit-role {
            opacity: 0;
            transition: opacity 0.2s;
        }

        .agent-circle:hover .edit-role {
            opacity: 1;
        }

        /* Update the agent-controls styles */
        .agent-controls {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            z-index: 1000;
        }

        .agent-controls button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .agent-controls button:hover {
            transform: scale(1.1);
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* Update the agents column styles */
        #agents-column {
            display: flex;
            flex-direction: row;
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            width: 100%;
            padding: 1rem;
            gap: 2rem;
            margin: 1rem auto; /* Center using margin auto */
            max-width: 800px; /* Limit maximum width */
        }

        .agent {
            flex: 0 1 auto; /* Don't grow, but allow shrink */
            width: 250px; /* Fixed width */
            min-width: 200px;
            max-width: 300px;
            margin: 0 1rem; /* Add horizontal margin */
        }

        /* Update for mobile */
        @media (max-width: 768px) {
            #agents-column {
                gap: 1rem;
                padding: 0.5rem;
            }
            
            .agent {
                width: 150px;
                min-width: 120px;
                margin: 0 0.5rem;
            }
        }

        #pauseButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #pauseButton.paused {
            background-color: rgb(220, 38, 38);
        }
    </style>
</head>

<body class="m-0 p-0 min-h-screen w-full flex flex-col">
    <div id="mainContainer">
        <div id="canvas-container">
            <div class="flex space-x-4 h-full">
                <div class="flex flex-col h-[calc(100%-3rem)] w-1/2">
                    <!-- Code Editor Section -->
                    <div class="h-2/3 mb-4">
                        <h3 class="text-lg font-semibold mb-2 text-white">Canvas Editor</h3>
                        <textarea 
                            id="canvas-editor" 
                            class="w-full h-[calc(100%-2rem)] p-4 font-mono text-sm bg-gray-800 text-white rounded-lg"
                            placeholder="Agents can write HTML code here..."
                        ></textarea>
                    </div>
                    <!-- Console Section -->
                    <div id="console-container" class="h-1/3 p-4 bg-gray-900 rounded-lg shadow-lg">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-lg font-semibold text-white">Console</h3>
                            <button 
                                onclick="clearConsole()" 
                                class="px-2 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600 transition"
                            >
                                Clear Console
                            </button>
                        </div>
                        <div 
                            id="console-output" 
                            class="font-mono text-sm h-[calc(100%-3rem)] overflow-y-auto p-2 bg-black text-white rounded"
                        >
                        </div>
                    </div>    
                </div>
                
                <!-- Preview Section -->
                <div class="w-1/2">
                    <h3 class="text-lg font-semibold mb-2 text-white">Live Preview</h3>
                    <div 
                        id="canvas-preview" 
                        class="w-full h-[calc(100%-3rem)] p-4 bg-white rounded-lg border overflow-auto"
                    >
                        Preview will appear here...
                    </div>
                </div>
            </div>
        </div>

        <div id="agents-column">  
        </div>
    </div>
    <input 
        id="chatInput" 
        type="text" 
        class="p-2.5 text-center text-lg rounded-xl shadow-lg" 
        placeholder="Type your message..."
    >
    <div class="agent-controls">
        <button id="addAgent" class="hover:bg-gray-800">+</button>
        <button id="removeAgent" class="hover:bg-gray-800">−</button>
        <button id="pauseButton" class="hover:bg-gray-800">⏸️</button>
    </div>

    

    <script>
        // Add these functions at the beginning of your script section
        function saveAgentContext(agentId, context) {
            try {
                localStorage.setItem(`agent_${agentId}_context`, context);
                logToConsole(`Context saved for Agent ${agentId}`, 'success');
            } catch (error) {
                logToConsole(`Error saving context: ${error.message}`, 'error');
            }
        }

        function loadAgentContext(agentId) {
            try {
                const savedContext = localStorage.getItem(`agent_${agentId}_context`);
                if (savedContext) {
                    agentContexts[agentId] = savedContext;
                    logToConsole(`Context loaded for Agent ${agentId}`, 'success');
                    return savedContext;
                }
            } catch (error) {
                logToConsole(`Error loading context: ${error.message}`, 'error');
            }
            return agentContexts[agentId] || ''; // Return default context if no saved context
        }

        const chatInput = document.getElementById('chatInput');
        const agentsContainer = document.getElementById('agentsContainer');
        const addAgentButton = document.getElementById('addAgent');
        const removeAgentButton = document.getElementById('removeAgent');
        let turn = 0;
        let agentCount = 2;  // Changed from 3 to 2
        let userMessageQueue = [];
        let isChatting = false;
        let voiceEnabled = {};
        let isPlaying = false;

        // Add this after your existing script declarations
        let availableAgents = [1, 2];  // Only 2 agents initially

        // Define the agent contexts
        const agentContexts = {
            1: "You are a creative designer with an eye for aesthetics. Focus on visual appeal, user experience, and innovative design concepts. Suggest beautiful UI elements and creative layouts.",
            2: "You are a super amazing web developer with deep expertise in HTML, CSS, and JavaScript. Focus on writing clean, efficient code and implementing complex functionality. Ensure best practices and responsive design."
        };

        // Add this after the agentContexts definition
        const agentRoles = {
            1: "Designer",
            2: "Developer"
        };

        // Add this function to get a random agent
        function getNextAgent() {
            if (availableAgents.length === 0) {
                // Reset the available agents if all have spoken
                for (let i = 1; i <= agentCount; i++) {
                    availableAgents.push(i);
                }
            }

            let lastSpeaker = null;
            const lastMessage = document.getElementById(`response${availableAgents[0]}`)?.textContent;
            
            // If this is a self-response (same agent speaking twice)
            if (availableAgents.length === 1) {
                const agent = availableAgents[0];
                availableAgents = [];
                return {
                    agentId: agent,
                    isSelfResponse: true
                };
            }

            // Get random index and remove that agent from available list
            const randomIndex = Math.floor(Math.random() * availableAgents.length);
            const selectedAgent = availableAgents.splice(randomIndex, 1)[0];
            
            return {
                agentId: selectedAgent,
                isSelfResponse: false
            };
        }

        // Function to get grayscale color based on agent number
        function getGrayScale(agentNumber, totalAgents) {
            const grayLevel = Math.max(300, 900 - ((agentNumber - 1) * (600 / (totalAgents - 1))));
            const level = Math.floor(grayLevel / 100) * 100;
            
            // Update both message and loading indicator color based on background brightness
            const agentDiv = document.querySelector(`#rectangle${agentNumber}`);
            if (agentDiv) {
                const messageElement = agentDiv.querySelector('.message');
                const loadingIndicator = agentDiv.querySelector('.loading-indicator');
                const textColor = level <= 400 ? '#1a202c' : '#ffffff';
                
                if (messageElement) {
                    messageElement.style.color = textColor;
                }
                if (loadingIndicator) {
                    loadingIndicator.style.color = textColor;
                }
            }
            
            return `bg-gray-${level}`;
        }

        // Function to update all agent colors
        function updateAgentColors() {
            for (let i = 1; i <= agentCount; i++) {
                const rectangle = document.getElementById(`rectangle${i}`);
                if (rectangle) {
                    // Remove existing gray background classes
                    rectangle.className = rectangle.className.replace(/bg-gray-\d+/g, '');
                    // Add new gray background class
                    rectangle.className += ` ${getGrayScale(i, agentCount)}`;
                }
            }
        }

        chatInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                const userInput = chatInput.value;
                chatInput.value = '';
                userMessageQueue.push(userInput);
                if (!isChatting) {
                    initiateChat(userInput, true);
                }
            }
        });

        addAgentButton.addEventListener('click', () => {
            agentCount++;
            const newAgentDiv = document.createElement('div');
            newAgentDiv.id = `agent-${agentCount}`;
            newAgentDiv.className = 'agent';
            document.getElementById('agents-column').appendChild(newAgentDiv);
            
            const agentElement = createAgentElement(agentCount);
            newAgentDiv.appendChild(agentElement);
            
            availableAgents.push(agentCount);

            // Show the role input for the new agent immediately
            const roleInput = agentElement.querySelector('.role-input');
            const roleDisplay = agentElement.querySelector('.role-display');
            roleDisplay.classList.add('hidden');
            roleInput.classList.remove('hidden');
            roleInput.focus();
        });

        removeAgentButton.addEventListener('click', () => {
            if (agentCount > 2) {  // Maintain minimum of 2 agents
                const lastAgent = document.getElementById(`agent-${agentCount}`);
                lastAgent.remove();
                
                // Remove from available agents
                const index = availableAgents.indexOf(agentCount);
                if (index > -1) {
                    availableAgents.splice(index, 1);
                }
                
                agentCount--;
            }
        });

        // Update the initialization code to load saved contexts
        document.addEventListener('DOMContentLoaded', () => {
            // Clear any existing agents
            const agentsColumn = document.getElementById('agents-column');
            agentsColumn.innerHTML = '';
            
            // Add the two agents with their saved or default contexts
            for (let i = 1; i <= 2; i++) {
                const agentDiv = createAgentElement(i);
                agentsColumn.appendChild(agentDiv);

                // Load saved context or use default
                const context = loadAgentContext(i);
                
                // Update the textarea with the loaded context
                const textarea = agentDiv.querySelector('textarea');
                textarea.value = context;

                // Set the initial context for each agent
                fetch('/train', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        agentId: i,
                        context: context
                    })
                });
            }
        });

        // Update the speakText function to signal when audio starts playing
        async function speakText(text, agentId) {
            try {
                const audioResponse = await fetch('/speak', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        text,
                        agentId
                    })
                });

                if (audioResponse.ok) {
                    isPlaying = true;
                    const audioBlob = await audioResponse.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    
                    // Signal when audio starts playing
                    audio.onplay = () => {
                        const agentDiv = document.getElementById(`rectangle${agentId}`);
                        const loadingIndicator = agentDiv.querySelector('.loading-indicator');
                        loadingIndicator.classList.remove('visible');
                    };
                    
                    // Wait for audio to complete
                    await new Promise((resolve) => {
                        audio.onended = () => {
                            isPlaying = false;
                            resolve();
                        };
                        audio.play();
                    });
                }
            } catch (error) {
                console.error('Error playing audio:', error);
                isPlaying = false;
            }
        }

        // Add this helper function to parse agent responses
        function parseAgentResponse(text) {
            try {
                // Look for JSON content between triple backticks
                const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/);
                if (jsonMatch) {
                    const jsonContent = jsonMatch[1];
                    return JSON.parse(jsonContent);
                }
                // If no JSON found, return text-only response
                return {
                    text: text,
                    code: null
                };
            } catch (error) {
                console.error('Error parsing agent response:', error);
                return {
                    text: text,
                    code: null
                };
            }
        }

        // Simplify updatePreview() to just handle basic XSS protection
        function updatePreview() {
            const editor = document.getElementById('canvas-editor');
            const preview = document.getElementById('canvas-preview');
            
            try {
                // Basic XSS protection by removing script tags
                const sanitizedCode = editor.value.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                preview.innerHTML = sanitizedCode;
                
                // Log success
                logToConsole('Preview updated successfully', 'success');
            } catch (error) {
                // Log error
                logToConsole(`Error updating preview: ${error.message}`, 'error');
                console.error('Error updating preview:', error);
            }
        }

        // Allow agents to update the canvas through a function
        function updateCanvas(htmlCode) {
            const editor = document.getElementById('canvas-editor');
            editor.value = htmlCode;
            updatePreview();
        }

        // Function to get current canvas content
        function getCanvasContent() {
            return document.getElementById('canvas-editor').value;
        }

        // Add this helper function to format messages with context and goal
        function formatMessageWithContext(message, currentCode, isUserMessage) {
            const prefix = isUserMessage ? 
                "Here's what we want to achieve:\n" : 
                "Continue building towards our goal:\n";

            return `${prefix}${message}

Current canvas content:
${currentCode || 'The canvas is empty.'}

Please build upon the existing code to work towards the goal. Provide a complete HTML solution that includes both existing and new code.`;
        }

        // Update the insertCodeAtLines function
        function insertCodeAtLines(currentCode, changes) {
            // Split current code into lines, handling empty canvas case
            let lines = currentCode ? currentCode.split('\n') : [];
            
            // Sort changes by line number in ascending order
            changes.sort((a, b) => a.line - b.line);
            
            for (const change of changes) {
                const lineNum = Math.max(1, change.line);  // Ensure line number is at least 1
                const codeToInsert = change.code;
                
                // If we're inserting at a line beyond the current content
                // pad with empty lines up to that point
                while (lines.length < lineNum - 1) {
                    lines.push('');
                }
                
                // Insert the new code at the specified line
                if (lineNum <= lines.length) {
                    // Insert between existing lines
                    lines.splice(lineNum - 1, 0, codeToInsert);
                } else {
                    // Append to the end
                    lines.push(codeToInsert);
                }
            }
            
            // Remove any empty lines at the end
            while (lines.length > 0 && lines[lines.length - 1].trim() === '') {
                lines.pop();
            }
            
            return lines.join('\n');
        }

        // Update the initiateChat function
        async function initiateChat(message, isUserMessage = false) {
            if (isPaused && !isUserMessage) {
                logToConsole('Agents are paused. Message queued.', 'warning');
                userMessageQueue.push(message);
                return;
            }

            // Wait if audio is playing
            while (isPlaying) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            isChatting = true;
            // Replace turn-based selection with random selection
            const { agentId: currentAgent, isSelfResponse } = isUserMessage ? 
                getNextAgent() : getNextAgent();
            const messagesContainer = document.getElementById(`messages${currentAgent}`);
            
            // Fade out existing message if it exists
            const existingMessage = messagesContainer.querySelector('.message');
            if (existingMessage) {
                existingMessage.classList.add('fading');
                // Remove the old message after fade animation
                setTimeout(() => {
                    existingMessage.remove();
                }, 500); // Match this with the CSS transition duration
            }

            // Create new message element with typing state
            const newMessage = document.createElement('div');
            newMessage.className = 'message text-white text-2xl text-center max-w-md mx-auto typing';
            newMessage.id = `response${currentAgent}`;
            messagesContainer.appendChild(newMessage);

            // Force reflow to trigger animation
            void newMessage.offsetWidth;
            newMessage.classList.add('visible');

            // Add self-response context to the message if needed
            const contextualizedMessage = isSelfResponse ? 
                `Elaborate on what you just said: ${message}` : 
                message;

            // Format message with context and goal
            const currentCanvasContent = getCanvasContent();
            const formattedMessage = formatMessageWithContext(contextualizedMessage, currentCanvasContent, isUserMessage);

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        message: formattedMessage, 
                        agentId: currentAgent,
                        agentCount,
                        isSelfResponse,
                        requireJson: true
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let fullResponse = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    fullResponse += decoder.decode(value, { stream: true });
                }

                // Parse the complete response
                try {
                    const parsedResponse = JSON.parse(fullResponse);
                    
                    // Stream the text portion
                    if (parsedResponse.text) {
                        let words = parsedResponse.text.split('');
                        for (const char of words) {
                            const charSpan = document.createElement('span');
                            charSpan.className = 'character';
                            
                            // Add a space after the character if it's followed by a space
                            if (char === ' ') {
                                charSpan.innerHTML = '&nbsp;';
                            } else {
                                charSpan.textContent = char;
                            }
                            
                            if (containsArabic(char)) {
                                charSpan.style.direction = 'rtl';
                            }
                            
                            newMessage.appendChild(charSpan);
                            await new Promise(resolve => setTimeout(resolve, voiceEnabled[currentAgent] ? 10 : 5));
                        }
                    }

                    // Handle code changes if they exist
                    if (parsedResponse.changes && parsedResponse.changes.length > 0) {
                        const editor = document.getElementById('canvas-editor');
                        const currentCode = editor.value;
                        
                        console.log('Current code:', currentCode);  // Debug log
                        console.log('Changes to apply:', parsedResponse.changes);  // Debug log
                        
                        // Apply the changes using our line-based insertion function
                        const updatedCode = insertCodeAtLines(currentCode, parsedResponse.changes);
                        
                        console.log('Updated code:', updatedCode);  // Debug log
                        
                        // Stream the updated code
                        // let currentDisplay = '';
                        // const diffChars = [...updatedCode];
                        
                        // for (let i = 0; i < diffChars.length; i++) {
                        //     currentDisplay = updatedCode.substring(0, i + 1);
                        //     editor.value = currentDisplay;
                        //     if (diffChars[i] === '>' || diffChars[i] === ';' || diffChars[i] === '}') {
                        //         updatePreview();
                        //     }
                        //     await new Promise(resolve => setTimeout(resolve, 1));
                        // }
                        
                        // Final update
                        editor.value = updatedCode;
                        updatePreview();
                    }

                    // Handle voice if enabled
                    if (voiceEnabled[currentAgent]) {
                        const loadingIndicator = messagesContainer.querySelector('.loading-indicator');
                        loadingIndicator.classList.add('visible');
                        await speakText(parsedResponse.text || '', currentAgent);
                        loadingIndicator.classList.remove('visible');
                    }

                    // Continue conversation
                    setTimeout(async () => {
                        while (isPlaying) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        if (userMessageQueue.length > 0) {
                            const userMessage = userMessageQueue.shift();
                            initiateChat(userMessage, true);
                        } else if (parsedResponse.text) {
                            initiateChat(parsedResponse.text);
                        }
                        isChatting = false;
                    }, 2000);

                } catch (error) {
                    console.error('Error parsing response:', error);
                    newMessage.textContent = 'Error processing response';
                }

            } catch (error) {
                console.error('Error in chat:', error);
                const loadingIndicator = messagesContainer.querySelector('.loading-indicator');
                loadingIndicator.classList.remove('visible');
                isChatting = false;
            }
        }

        function createAgentElement(agentNumber) {
            const agentDiv = document.createElement('div');
            agentDiv.id = `agent-${agentNumber}`;
            // Update the className to use Tailwind classes
            agentDiv.className = 'agent flex flex-col items-center gap-2 flex-1 p-4 border-2 border-white/10 rounded-2xl bg-black/10 backdrop-blur-sm hover:border-white/20 transition-all duration-300 max-w-[300px] min-w-[200px] m-2';
            agentDiv.innerHTML = `
                <div class="message-container">
                    <div id="messages${agentNumber}">
                        <div id="response${agentNumber}" class="message">
                        </div>
                    </div>
                    <div class="loading-indicator">
                        <div class="loading-dots">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                    </div>
                </div>
                <div class="agent-circle group relative">
                    <span class="role-display">${agentRoles[agentNumber] || 'New Agent'}</span>
                    <input 
                        type="text" 
                        class="role-input hidden absolute inset-0 w-full h-full bg-black/50 text-white text-center rounded-full"
                        value="${agentRoles[agentNumber] || ''}"
                        placeholder="Enter role..."
                    >
                    <button class="edit-role absolute -top-2 -right-2 bg-blue-500 rounded-full w-5 h-5 text-xs hidden group-hover:flex items-center justify-center">
                        ✏️
                    </button>
                </div>
                <div class="agent-buttons w-full flex flex-col gap-2">
                    <button class="train-button bg-blue-500 text-white rounded p-2 text-sm hover:scale-105 transition-transform">
                        Train
                    </button>
                    <button class="model-button bg-indigo-500 text-white rounded p-2 text-sm hover:scale-105 transition-transform">
                        Claude
                    </button>
                    <button class="personality-button bg-yellow-500 text-white rounded p-2 text-sm hover:scale-105 transition-transform">
                        ${getRandomPersonality()}
                    </button>
                    <button class="voice-button bg-red-500 text-white rounded p-2 text-sm hover:scale-105 transition-transform">
                        Voice
                    </button>
                </div>
                <div class="context-input hidden w-full">
                    <textarea 
                        class="w-full p-2 text-black rounded"
                        placeholder="Enter agent context..."
                        rows="3"
                    ></textarea>
                    <button class="save-context bg-green-500 text-white px-2 py-1 rounded text-sm mt-1 w-full">
                        Save
                    </button>
                </div>
            `;

            // Add existing event listeners
            const trainButton = agentDiv.querySelector('.train-button');
            const contextInput = agentDiv.querySelector('.context-input');
            const saveContextButton = agentDiv.querySelector('.save-context');
            const textarea = agentDiv.querySelector('textarea');
            const modelButton = agentDiv.querySelector('.model-button');
            const voiceButton = agentDiv.querySelector('.voice-button');

            // Add model toggle functionality
            modelButton.addEventListener('click', async () => {
                try {
                    const response = await fetch('/toggle-model', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            agentId: agentNumber
                        })
                    });
                    
                    if (response.ok) {
                        const { model } = await response.json();
                        modelButton.textContent = model === 'gpt' ? 'GPT' : 'Claude';
                        modelButton.classList.remove('bg-purple-500', 'bg-indigo-500');
                        modelButton.classList.add(model === 'gpt' ? 'bg-purple-500' : 'bg-indigo-500');
                    }
                } catch (error) {
                    console.error('Error toggling model:', error);
                }
            });

            // Existing event listeners...
            trainButton.addEventListener('click', () => {
                contextInput.classList.toggle('hidden');
            });

            // Update the save context button event listener
            saveContextButton.addEventListener('click', async () => {
                const context = textarea.value;
                try {
                    // Save to localStorage
                    saveAgentContext(agentNumber, context);
                    
                    // Update server
                    const response = await fetch('/train', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            agentId: agentNumber,
                            context: context
                        })
                    });
                    
                    if (response.ok) {
                        contextInput.classList.add('hidden');
                        trainButton.classList.add('bg-green-500');
                        setTimeout(() => {
                            trainButton.classList.remove('bg-green-500');
                            trainButton.classList.add('bg-blue-500');
                        }, 1000);
                    }
                } catch (error) {
                    logToConsole(`Error training agent: ${error.message}`, 'error');
                }
            });

            // Set initial model button state based on agent number
            if (agentNumber === 1) {
                modelButton.textContent = 'Claude';
                modelButton.classList.remove('bg-purple-500');
                modelButton.classList.add('bg-indigo-500');
            }

            // Add personality button click handler
            const personalityButton = agentDiv.querySelector('.personality-button');
            personalityButton.addEventListener('click', async () => {
                try {
                    const currentPersonality = personalityButton.textContent.toLowerCase();
                    const personalityKeys = Object.keys(personalities);
                    const currentIndex = personalityKeys.indexOf(currentPersonality);
                    const nextIndex = (currentIndex + 1) % personalityKeys.length;
                    const newPersonality = personalityKeys[nextIndex];
                    
                    const response = await fetch('/set-personality', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            agentId: agentNumber,
                            personality: newPersonality
                        })
                    });
                    
                    if (response.ok) {
                        personalityButton.textContent = newPersonality.charAt(0).toUpperCase() + 
                                             newPersonality.slice(1);
                        // Visual feedback
                        personalityButton.classList.add('bg-green-500');
                        setTimeout(() => {
                            personalityButton.classList.remove('bg-green-500');
                            personalityButton.classList.add('bg-yellow-500');
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error setting personality:', error);
                }
            });

            voiceButton.addEventListener('click', () => {
                const agentId = parseInt(agentDiv.id.replace('rectangle', ''));
                voiceEnabled[agentId] = !voiceEnabled[agentId];
                voiceButton.classList.toggle('enabled', voiceEnabled[agentId]);
            });

            // After creating the element, set the initial colors
            const level = Math.max(300, 900 - ((agentNumber - 1) * (600 / (agentCount - 1))));
            const textColor = level <= 400 ? '#1a202c' : '#ffffff';
            const loadingIndicator = agentDiv.querySelector('.loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.color = textColor;
            }

            // Add role editing functionality
            const roleDisplay = agentDiv.querySelector('.role-display');
            const roleInput = agentDiv.querySelector('.role-input');
            const editButton = agentDiv.querySelector('.edit-role');

            editButton.addEventListener('click', () => {
                roleDisplay.classList.add('hidden');
                roleInput.classList.remove('hidden');
                roleInput.focus();
            });

            // Update the role editing functionality to save context
            roleInput.addEventListener('blur', () => {
                const newRole = roleInput.value.trim();
                if (newRole) {
                    agentRoles[agentNumber] = newRole;
                    roleDisplay.textContent = newRole;
                    
                    // Create and save the new context
                    const newContext = `You are a ${newRole}. Focus on providing expertise and insights related to ${newRole}.`;
                    saveAgentContext(agentNumber, newContext);
                    
                    // Update server
                    fetch('/train', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            agentId: agentNumber,
                            context: newContext
                        })
                    });
                }
                roleDisplay.classList.remove('hidden');
                roleInput.classList.add('hidden');
            });

            roleInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    roleInput.blur();
                }
            });

            return agentDiv;
        }

        // Initialize agent colors
        updateAgentColors();

        // Add this after your existing script declarations
        const personalities = {
            witty: "You are witty and sarcastic, often making clever observations with a hint of playful mockery.",
            formal: "You are extremely formal and professional, speaking like a distinguished academic or diplomat.",
            casual: "You are super casual and laid-back, using informal language and speaking like a close friend.",
            poetic: "You are poetic and romantic, often speaking in metaphors and flowery language.",
            nerdy: "You are a tech enthusiast who loves making references to science, gaming, and pop culture.",
            philosophical: "You are deeply philosophical, always trying to explore the deeper meaning of conversations.",
            dramatic: "You are theatrical and dramatic, treating every interaction like it's a scene from a play.",
            optimistic: "You are extremely positive and encouraging, always finding the bright side of things.",
            mysterious: "You are enigmatic and mysterious, speaking in riddles and cryptic statements.",
            rebellious: "You are a nonconformist who questions everything and challenges conventional wisdom."
        };

        // Add this function to get a random personality
        function getRandomPersonality() {
            const keys = Object.keys(personalities);
            return keys[Math.floor(Math.random() * keys.length)];
        }

        // Add this helper function to detect Arabic text
        function containsArabic(text) {
            const arabicPattern = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
            return arabicPattern.test(text);
        }

        // Console functionality
        function logToConsole(message, type = 'info') {
            const consoleOutput = document.getElementById('console-output');
            const logEntry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            
            logEntry.className = 'py-1 border-b border-gray-800';
            
            // Set color based on message type
            switch(type) {
                case 'error':
                    logEntry.className += ' text-red-500';
                    break;
                case 'warning':
                    logEntry.className += ' text-yellow-500';
                    break;
                case 'success':
                    logEntry.className += ' text-green-500';
                    break;
                default:
                    logEntry.className += ' text-gray-300';
            }
            
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        function clearConsole() {
            const consoleOutput = document.getElementById('console-output');
            consoleOutput.innerHTML = '';
        }

        // Add error handling for code changes
        if (parsedResponse.changes && parsedResponse.changes.length > 0) {
            try {
                // ... existing code update logic ...
                logToConsole('Code updated successfully', 'success');
            } catch (error) {
                logToConsole(`Error updating code: ${error.message}`, 'error');
            }
        }

        // Add error event listener for preview iframe
        document.getElementById('canvas-preview').addEventListener('error', function(e) {
            logToConsole(`Resource error: ${e.message}`, 'error');
        });

        // Add pause functionality
        let isPaused = false;
        const pauseButton = document.getElementById('pauseButton');

        pauseButton.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? '▶️' : '⏸️';
            pauseButton.classList.toggle('paused');
            
            if (isPaused) {
                logToConsole('Agents paused', 'warning');
            } else {
                logToConsole('Agents resumed', 'success');
                // Resume processing if there are messages in queue
                if (userMessageQueue.length > 0 && !isChatting) {
                    const nextMessage = userMessageQueue.shift();
                    initiateChat(nextMessage, true);
                }
            }
        });
    </script>
</body>

</html>
